 /*
 * MAIN Generated Driver File
 * 
 * @file main.c
 * 
 * @defgroup main MAIN
 * 
 * @brief This is the generated driver implementation file for the MAIN driver.
 *
 * @version MAIN Driver Version 1.0.2
 *
 * @version Package Version: 3.1.2
*/

/*
© [2024] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/
#include "mcc_generated_files/system/system.h"  // Include the master header file generated by MCC
#include <stdio.h>

#define STRAP_PIN     PORTAbits.RA0 // Pin = hi -> master 
#define SLAVE_SELECT  PORTBbits.RB3 // chip/slave select
#define TIME_TO_READ  100           // time between reading sensor 
#define TICK_THRESHOLD 10 // Define an appropriate threshold for ticks
#define DEFAULT_TEMPERATURE 0x0019 // 25 degC
volatile uint16_t tick_counter = 0; // Timer tick count 
uint16_t last_uart1_data_tick = 0;

uint8_t high_byte1; 
uint8_t low_byte1; 
uint8_t high_byte2;
uint8_t low_byte2;
int data_being_used_by_spi;
bool data1_ready;
bool data2_ready;               
bool data1_latest;
bool data2_latest;
bool expecting_high_byte = true;

// Function declarations
void SPI_Write(uint16_t);
uint16_t SPI_Read(void);
void UART_SendChar(uint8_t);
uint8_t UART_ReceiveChar(void);
void TMP122_Init();
uint16_t read_temperature();
void Error_Handler(char *);
void reset_counter();
void ticker();

// Function implementations
void SPI_Write(uint16_t data) {
    SDI_SetDigitalOutput(); //set RB4 as output
    
    uint8_t buffer[2]; 
    buffer[0] = (data >> 8) & 0xFF; // High byte 
    buffer[1] = data & 0xFF; // Low byte 
    SPI1_BufferExchange(buffer, 2); // Send the buffer
    
}

uint16_t SPI_Read(void) {
    SDI_SetDigitalInput(); //set RB4 as input
    
    uint8_t buffer[2]; 
    uint16_t data ; 
    SPI1_BufferExchange(buffer, 2); // Receive the buffer 
    if ((buffer[0] << 8 | buffer[1]) == 0xFFFF) {
        Error_Handler("SPI Read Error");
    }
    data = ((uint16_t)buffer[0] << 8) | (uint16_t)buffer[1]; // Combine high and low bytes
    
    return data;
}


void UART_SendChar(uint8_t data) {
    while (!EUSART1_IsTxReady());
    EUSART1_Write(data);
}


void TMP122_Init(void) {
    SPI_Write(0x3E87);  // Initialize TMP122's high temp threshold to 125 degC
    SPI_Write(0x0007);  // Initialize TMP122's high temp threshold to 125 degC
}

uint16_t read_temperature(void) {
    return SPI_Read();  // Read temperature data
}

void Error_Handler(char *message) {
    // Handle error
    printf("Error: %s\n", message);
    while (1);
}

void ticker(void){
    tick_counter++; // increment this counter each TMR0 period (1 mS)) in which an interrupt is flagged
    // Interrupt flag cleared automatically in TMR0_ISR()
}

void reset_counter(void) {
    tick_counter = 0;
}


void process_serial_data(void) {
    if (!EUSART1_IsRxReady())
    {
        if (tick_counter < TICK_THRESHOLD) { 
            // Received byte within threshold, it's the low byte 
            if(data_being_used_by_spi != 1){
                low_byte1 = EUSART1_Read();
                data1_ready = true;
                data2_latest = false;
                data1_latest = true;
            } else if(data_being_used_by_spi != 2) {
                low_byte2 = EUSART1_Read();
                data2_ready = true;
                data1_latest = false;
                data2_latest = true;                
            }
    //        expecting_high_byte = true; 
        } else { 
            // Received byte after a long time, it's the high byte 
            if(data_being_used_by_spi != 1){
                data1_ready = false;
                high_byte1 = EUSART1_Read();
            } else if(data_being_used_by_spi != 2){
                data2_ready = false;
                high_byte2 = EUSART1_Read();
            }
    //        expecting_high_byte = false; 
        } 
        reset_counter(); // Reset tick count after processing
    }
}

void main(void) {
    /*
     * SYSTEM_Initialize does the following
     * EUSART1
     * ABDEN disabled; WUE disabled; BRG16 16bit_generator; SCKP Non-Inverted; 
     * BAUD1CON = 0x48; 
     * 
     * ADDEN disabled; CREN enabled -> continuous reception; 
     * SREN disabled; RX9 8-bit; SPEN enabled -> UART enabled
     * RC1STA = 0x90; 
     * 
     * TX9D 0x0; BRGH hi_speed; SENDB sync_break_complete; SYNC asynchronous; 
     * TXEN enabled -> transmission enabled; TX9 8-bit; CSRC client; 
     * TX1STA = 0x26; 
     * 
     * SPBRGL 207; //9600 baud
     * SP1BRGL = 0xCF; 
     * 
     * SPBRGH 0; 
     * SP1BRGH = 0x0; 
     * 
     * EUSART2 
     * same as EUSART 1 
     */
    SYSTEM_Initialize();  // Initialize the system using MCC
    INTERRUPT_GlobalInterruptEnable();      
    INTERRUPT_PeripheralInterruptEnable();
    TMR0_PeriodMatchCallbackRegister(ticker);
    SPI1_Open(0); //SSP1STAT = 0x00 -> bit7 (SMP) Input data sampled at middle of data output time
                  //                -> bit6 (CKE) Transmit occurs on transition from Idle to active clock state
                  //SSP1CON1 = 0x02 -> bit[7:6] (WCOL:SSPOV) no collision, no overflow 
                  //                -> bit5 (SSPEN) Enables serial port and configures 
                  //                ->              SCK, SDO, SDI and SS as the source of the serial port pins
                  //                -> bit4 (CKP) Idle state for clock is a low level
                  //                -> bit[3:0] (SSPM) SPI Host mode, clock = FOSC/64
                  //SSP1CON3 = 0x10 -> bit4 (BOEN) SSPxBUF updates every time that a 
                  //                               new data byte is shifted in ignoring the BF bit 
                  //SSP1ADD  = 0x0f -> 125kHz

    IO_RA0_SetDigitalInput();  // Set STRAP_PIN as input

    if (STRAP_PIN) {
        // Master mode
        // CS/SS is output active low. This will select TMP122 permanently.
        CS_TRIS = 0; // set RB3 as Output
        CS_SetLow(); //set RB3 low to select TMP122
//        TMP122_Init();
        uint16_t temperature;

        while (1) {
            temperature = read_temperature(); // Get temperature data from TMP122
            UART_SendChar((temperature >> 8) & 0xFF);  //  high byte in SPI buffer
            UART_SendChar(temperature & 0xFF);  // Send low byte
            printf("Temperature: %u\n", temperature);  // Debugging output
            __delay_ms(TIME_TO_READ);  // Delay in milliseconds, default = 100 mS
        }
    } else {
        // Slave mode
        
        //register uart1 rx complate interrupt call back function. 

        
        // CS/SS is input active low
        CS_TRIS = 1; // set RB3 as Input
        uint16_t data;
        uint16_t data1;
        uint16_t data2;
        
        while (1) {
            process_serial_data();
//            if (expecting_high_byte == false){
                data1 = ((uint16_t)high_byte1 << 8) | (uint16_t)low_byte1; // Combine high and low bytes
                data2 = ((uint16_t)high_byte2 << 8) | (uint16_t)low_byte2; // Combine high and low bytes
//            }
            if (SLAVE_SELECT == 0) {            // Transmit SPI data when CS/SS is low.
                if(data1_ready && data1_latest){
                    data_being_used_by_spi = 1;
                    SPI_Write(data1);
                    data = data1;
                } else if (data2_ready && data2_latest){
                    data_being_used_by_spi = 2;
                    SPI_Write(data2);
                    data = data2;
                } else {
                    data_being_used_by_spi = 0;
                    SPI_Write(DEFAULT_TEMPERATURE);
                    data = DEFAULT_TEMPERATURE;
                }
                printf("Sent data: %u\n", data);  // Debugging output
            }
        }
    }
}
