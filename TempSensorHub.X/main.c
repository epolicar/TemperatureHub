 /*
 * MAIN Generated Driver File
 * 
 * @file main.c
 * 
 * @defgroup main MAIN
 * 
 * @brief This is the generated driver implementation file for the MAIN driver.
 *
 * @version MAIN Driver Version 1.0.2
 *
 * @version Package Version: 3.1.2
*/

/*
© [2024] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/
#include "mcc_generated_files/system/system.h"  // Include the master header file generated by MCC
#include <stdio.h>
#include <string.h>

#define STRAP_PIN     PB_PORT // Pin = hi -> master 
#define TIME_TO_READ  100           // time between reading sensor 
#define TICK_THRESHOLD 10 // Define an appropriate threshold for ticks
#define DEFAULT_TEMPERATURE 0x0019 // 25 degC
#define DEBUG

volatile uint16_t tick_counter = 0; // Timer tick count 
uint16_t last_uart1_data_tick = 0;
uint8_t high_byte1; 
uint8_t low_byte1; 
uint8_t high_byte2;
uint8_t low_byte2;
int data_being_used_by_spi;
bool data1_ready;
bool data2_ready;               
bool data1_latest;
bool data2_latest;
bool expecting_high_byte = true;


// Function declarations
void SPI_Write(uint16_t);
uint16_t SPI_Read(void);
void UART_SendChar(uint8_t);
uint8_t UART_ReceiveChar(void);
void TMP122_Init();
uint16_t read_temperature();
void Error_Handler(char *);
uint8_t high_byte_spi = 0;
uint8_t low_byte_spi = 0;
uint8_t data_ptr = 0;
void reset_counter();
void ticker();
void test1(int);
void UART_WriteString(const char *);
void process_serial_data(void);
void response_to_spi(void);
void uart1_handler(void);

// Function implementations

//void SPI_Write(uint16_t data) {
////    SDI_SetDigitalOutput(); //set RB4 as output
//
//    uint8_t buffer[2];
//    buffer[0] = (data >> 8) & 0xFF; // High byte 
//    buffer[1] = data & 0xFF; // Low byte
//    printf("buffer0 is %x \n\r", buffer[0]);
//    printf("buffer1 is %x \n\r", buffer[1]);       
//    SPI1_BufferExchange(&buffer[0], 2); // Send the buffer }
//}

uint16_t SPI_Read(void) {
//    SDI_SetDigitalInput(); //set RB4 as input											 
    uint8_t buffer[2]; 
    uint16_t data; 
    SPI1_BufferExchange(buffer, 2); // Receive the buffer 
    data = ((uint16_t)buffer[0] << 8) | (uint16_t)buffer[1]; // Combine high and low bytes 
    if (data == 0xFFFF) {
        Error_Handler("SPI Read Error");
    }
    return data;
}

void UART2_SendChar(uint8_t data) {
    while (!UART2_IsTxReady());
    EUSART2_Write(data);
}

// Function to send a string via UART2
void UART2_SendString(const char* str) {
    while (*str != '\0') {        // While we haven't reached the end of the string
        UART2_SendChar(*str);      // Send each character
        str++;                     // Move to the next character
    }
}

void UART_SendChar(uint8_t data) {
    while (!UART1_IsTxReady());
    EUSART1_Write(data);
}

//uint8_t UART_ReceiveChar(void) {
//    while (!UART1__IsRxReady());
//    return EUSART1_Read();
//}
//
//void TMP122_Init(void) {
//    SPI_Write(0x3E87);  // Initialize TMP122's high temp threshold to 125 degC
//    SPI_Write(0x0007);  // Initialize TMP122's high temp threshold to 125 degC
//}

uint16_t read_temperature(void) {
    return SPI_Read();  // Read temperature data
}

void Error_Handler(char *message) {
    // Handle error
    printf("Error: %s\n", message);
    while (1);
}



void ticker(void){
    tick_counter++; // increment this counter each TMR0 period (1 mS)) in which an interrupt is flagged
    // Interrupt flag cleared automatically in TMR0_ISR()
}

void reset_counter(void) {
    tick_counter = 0;
}

void test1(int loop){
    for( int i=0; i<loop; i++) {
        LATD2 = 1;  // Set RD2 high
        __delay_ms(500);  // Wait for 1 second

        LATD2 = 0;  // Set RD2 lows
        __delay_ms(500);  // Wait for 1 second
    }
}

//void UART_WriteString(const char *message)
//{
//    for(int i = 0; i < (int)strlen(message); i++)
//    {
//        while(!UART2.IsTxReady())
//        {
//            ;
//        };
//        (void) UART2.Write(message[i]);
//    }
//}

// Define system frequency and baud rate
#define BAUD_RATE 9600      // Desired baud rate

//void process_serial_data(void) {
//    if (!EUSART1_IsRxReady())
//    {
//        if (tick_counter < TICK_THRESHOLD) { 
//            // Received byte within threshold, it's the low byte 
//            if(data_being_used_by_spi != 1){
//                low_byte1 = EUSART1_Read();
//                data1_ready = true;
//                data2_latest = false;
//                data1_latest = true;
//            } else if(data_being_used_by_spi != 2) {
//                low_byte2 = EUSART1_Read();
//                data2_ready = true;
//                data1_latest = false;
//                data2_latest = true;                
//            }
//    //        expecting_high_byte = true; 
//        } else { 
//            // Received byte after a long time, it's the high byte 
//            if(data_being_used_by_spi != 1){
//                data1_ready = false;
//                high_byte1 = EUSART1_Read();
//            } else if(data_being_used_by_spi != 2){
//                data2_ready = false;
//                high_byte2 = EUSART1_Read();
//            }
//    //        expecting_high_byte = false; 
//        } 
//        reset_counter(); // Reset tick count after processing
//    }
//}
//software base. 
//IT"S TOO SLOW.. around 8uSecond response. 
//void response_to_spi(void)
//{
//    if(!SS_GetValue()){
//        uint16_t data = 0xaaaa;
//        uint16_t mask = 0x8000;
//        bool val = true;
//        for( int i=1; i<16; i++)
//        {
//            SDI_SetHigh();
//            /*
//            if(val){
//                SDI_SetHigh();
//                val = false;
//            } else {
//                SDI_SetLow();
//                val = true;
//            } */
//            //push the data
//            /*
//            if(data & mask){
//                SDI_SetHigh();
//            } else  {
//                SDI_SetLow();
//            }
//            mask = mask >> 1;
//             */
//            //wait for clock to go high
//            while(!SCK_GetValue());
//            SDI_SetLow();
//            //wait for clock to go low
//            while(SCK_GetValue());
//        }
//    }
//}

void uart1_handler(void)
{
//    if(!data_ptr)
//    {
    if (tick_counter > TICK_THRESHOLD) {
        high_byte_spi = EUSART1_Read();
        data_ptr = 1;
    }else {
        low_byte_spi = EUSART1_Read();
        data_ptr = 0;
    }
    reset_counter();
}

void main(void) {
    /*
     * SYSTEM_Initialize does the following
     * EUSART1
     * ABDEN disabled; WUE disabled; BRG16 16bit_generator; SCKP Non-Inverted; 
     * BAUD1CON = 0x48; 
     * 
     * ADDEN disabled; CREN enabled -> continuous reception; 
     * SREN disabled; RX9 8-bit; SPEN enabled -> UART enabled
     * RC1STA = 0x90; 
     * 
     * TX9D 0x0; BRGH hi_speed; SENDB sync_break_complete; SYNC asynchronous; 
     * TXEN enabled -> transmission enabled; TX9 8-bit; CSRC client; 
     * TX1STA = 0x26; 
     * 
     * SPBRGL 207; //9600 baud
     * SP1BRGL = 0xCF; 
     * 
     * SPBRGH 0; 
     * SP1BRGH = 0x0; 
     * 
     * EUSART2 
     * same as EUSART 1 
     * 
     * SPI CLK: RB5
     * SPI SDO/I: RB4
     * SPI CS: RD5
     * TX: RC6
     * RX: RC7
     * 
     * Debug RX:RD1
     * Debug TX:RD0
     * 
     */    
    SYSTEM_Initialize();  // Initialize the system using MCC
    EUSART2_Enable();
    EUSART2_TransmitEnable();

    //All this already configured in pins.c, but configuring again
    PB_SetDigitalMode(); 
    SDO_SetDigitalMode();
    SCK_SetDigitalMode();
    TX1_SetDigitalMode();
    RX1_SetDigitalMode();
    TX2_SetDigitalMode();
    RX2_SetDigitalMode();
    SS_SetDigitalMode();
    
    PB_SetDigitalOutput(); //Personality: RA0
    SDO_SetDigitalOutput(); //SPI SDO/I: RB4
    SCK_SetDigitalInput(); // SPI CLK: RB5
    TX1_SetDigitalOutput(); // TX: RC6
    RX1_SetDigitalInput(); // RX: RC7
    TX2_SetDigitalOutput(); // Debug TX:RD0
    RX2_SetDigitalInput(); // Debug RX:RD1
    SS_SetDigitalInput(); // SPI CS: RD5
    

    INTERRUPT_GlobalInterruptEnable();
    INTERRUPT_PeripheralInterruptEnable();
    TMR0_PeriodMatchCallbackRegister(ticker);
    SPI1_Open(0); //SSP1STAT = 0x00 -> bit7 (SMP) Input data sampled at middle of data output time
                  //                -> bit6 (CKE) Transmit occurs on transition from Idle to active clock state
                  //SSP1CON1 = 0x02 -> bit[7:6] (WCOL:SSPOV) no collision, no overflow 
                  //                -> bit5 (SSPEN) Enables serial port and configures 
                  //                ->              SCK, SDO, SDI and SS as the source of the serial port pins
                  //                -> bit4 (CKP) Idle state for clock is a low level
                  //                -> bit[3:0] (SSPM) SPI Host mode, clock = FOSC/64
                  //SSP1CON3 = 0x10 -> bit4 (BOEN) SSPxBUF updates every time that a 
                  //                               new data byte is shifted in ignoring the BF bit 
                  //SSP1ADD  = 0x0f -> 125kHz
    TMR0_Start;
    
    if (STRAP_PIN) {
//   if (false) {    
        /****** Master mode:*******/ 
        /****SS out put at RB3*****/
        test1(1);
        UART2_SendString("Mode: master\n\r");
//        if (SPI1_Open(0)) {
//            LATB3 = 0;
//            //TMP122_Init();
//            LATB3 = 1;
//            UART2_SendString("TMP122_Init done\n\r");
//        } else {
//            UART2_SendString("halt\n\r");
//            while(1);
//        }
        uint16_t temperature;

        while (1) {
            SS_SetLow(); 
            temperature = read_temperature(); // Get temperature data from TMP122
            SS_SetHigh();
            UART_SendChar((temperature >> 8) & 0xFF);  //  Send high byte in SPI buffer
            UART_SendChar(temperature & 0xFF);  // Send low byte
#ifdef DEBUG
            temperature = temperature >> 7;
            printf("Temperature: %u\n\r", temperature);  // Debugging output
            __delay_ms(TIME_TO_READ);  // Delay in milliseconds, default = 100 mS
#endif
            __delay_ms(50);  // Delay 1 second
        }
    } else {
        //test1(2);
        UART2_SendString("Mode: slave\n\r");
        // Slave mode
 //       SSP1CON1 = 0x05;
        //CS_TRIS = 1; //RB3 is input
        SCK_TRIS = 1; //RB5 is inputs
        uint8_t high_byte, low_byte;
        uint8_t buffer[2]; 
        // CS/SS is input active low
        //CS_TRIS = 1; // set RB3 as Input
        uint16_t data;
        uint16_t data1;
        uint16_t data2;
        //manual override
        //SDI_TRIS = 0; //set sdi/o as output

//        while(1){
//            response_to_spi();
//        }
        
        bool data_ptr = 0;
//        IO_RD5_TRIS = 1;
        
        bool detect_high_cs = false;
        UART2_SendString("enabling usart1\n\r");
        EUSART1_Enable();
        EUSART1_ReceiveEnable();
        EUSART1_TransmitEnable();
        UART2_SendString("registering handler\n\r");
        EUSART1_RxCompleteCallbackRegister(&uart1_handler);
        
        //UART.RxCompleteCallbackRegister(&UART_echoCharacters);
        INTERRUPT_GlobalInterruptEnable();
        INTERRUPT_PeripheralInterruptEnable();        
        
        
        UART2_SendString("entering loop\n\r");
        while (1) {
            //high_byte = UART_ReceiveChar();
            //low_byte = UART_ReceiveChar();
            //data = (high_byte << 8) | low_byte;  // Combine high and low bytes
                //printf("Received data: %x\n\r", data);  // Debugging output
            //printf("waiting for master to read the data\n\r");
            //SPI_Write(data);  // Send data via SPI
//            process_serial_data();
            
			SSP1BUF = high_byte_spi;
            data_ptr = 1;
            while (!PIR3bits.SSP1IF)
            {
                
                //SS is low, check if SS goes up
                if(!SS_GetValue()){
                    detect_high_cs = true;
                } 
                
                if (detect_high_cs){
                    if(SS_GetValue()){
                        data_ptr = 0;
                        break;
                    }
                }
                // Wait for flag to get set */
            }
            
            if(data_ptr)
            {
                PIR3bits.SSP1IF = 0;       //clear flag to get ready for the next transmission     
                SSP1BUF = low_byte_spi;                
            }
            while (!PIR3bits.SSP1IF)
            {
                //check if the ss goes up
                if(SS_GetValue()){
                    data_ptr = 0;
                    break;
                }

//                data1 = ((uint16_t)high_byte1 << 8) | (uint16_t)low_byte1; // Combine high and low bytes
//                data2 = ((uint16_t)high_byte2 << 8) | (uint16_t)low_byte2; // Combine high and low bytes

                
//            if (SS_GetValue() == 0) {            // Transmit SPI data when CS/SS is low.
//                if(data1_ready && data1_latest){
//                    data_being_used_by_spi = 1;
//                    SPI_Write(data1);
//                    data = data1;
//                } else if (data2_ready && data2_latest){
//                    data_being_used_by_spi = 2;
//                    SPI_Write(data2);
//                    data = data2;
//                } else {
//                    data_being_used_by_spi = 0;
//                    SPI_Write(DEFAULT_TEMPERATURE);
//                    data = DEFAULT_TEMPERATURE;
//                }
//                printf("Sent data: %u\n", data);  // Debugging output
// 
            }
        }
    }
}