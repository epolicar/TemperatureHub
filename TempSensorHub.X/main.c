 /*
 * MAIN Generated Driver File
 * 
 * @file main.c
 * 
 * @defgroup main MAIN
 * 
 * @brief This is the generated driver implementation file for the MAIN driver.
 *
 * @version MAIN Driver Version 1.0.2
 *
 * @version Package Version: 3.1.2
*/

/*
© [2024] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/
#include "mcc_generated_files/system/system.h"  // Include the master header file generated by MCC
#include <stdio.h>
#include "mcc_generated_files/system/system.h"
#include <string.h>

#define STRAP_PIN      PORTAbits.RA0
#define DEBUG

// Function declarations
void SPI_Write(uint16_t);
uint16_t SPI_Read(void);
void UART_SendChar(uint8_t);
uint8_t UART_ReceiveChar(void);
void TMP122_Init();
void putch(char);
uint16_t read_temperature();
void Error_Handler(char *);
uint8_t high_byte_spi = 0;
uint8_t low_byte_spi = 0;
uint8_t data_ptr = 0;

// Function implementations

void SPI_Write(uint16_t data) {
    uint8_t buffer[2];
    buffer[0] = (data >> 8) & 0xFF; // High byte 
    buffer[1] = data & 0xFF; // Low byte
    //buffer[1] = 0x1; // Low byte
    printf("buffer0 is %x \n\r", buffer[0]);
    printf("buffer1 is %x \n\r", buffer[1]);       
    SPI1_BufferExchange(&buffer[0], 2); // Send the buffer }
}

uint16_t SPI_Read(void) {
    uint8_t buffer[2]; 
    buffer[0] = 0x12;
    buffer[1] = 0x34;
    uint16_t data; 
    SPI1_BufferExchange(buffer, 2); // Receive the buffer 
    if (buffer == 0xFFFF) {
        Error_Handler("SPI Read Error");
    }
    data = (buffer[0] << 8) | buffer[1]; // Combine high and low bytes 
    return data;
}

void UART2_SendChar(uint8_t data) {
    while (!UART2_IsTxReady());
    EUSART2_Write(data);
}

// Function to send a string via UART2
void UART2_SendString(const char* str) {
    while (*str != '\0') {        // While we haven't reached the end of the string
        UART2_SendChar(*str);      // Send each character
        str++;                     // Move to the next character
    }
}

void UART_SendChar(uint8_t data) {
    while (!UART1_IsTxReady());
    EUSART1_Write(data);
}

uint8_t UART_ReceiveChar(void) {
    while (!UART1__IsRxReady());
    return EUSART1_Read();
}

void putch(char data) {
    while (!EUSART2_IsTxReady());
    EUSART2_Write(data);
}

void TMP122_Init(void) {
    SPI_Write(0x0000);  // Initialize TMP122
}

uint16_t read_temperature(void) {
    return SPI_Read();  // Read temperature data
}

void Error_Handler(char *message) {
    // Handle error
    printf("Error: %s\n", message);
    while (1);
}



void test1(int loop){
    for( int i=0; i<loop; i++) {
        LATD2 = 1;  // Set RD2 high
        __delay_ms(500);  // Wait for 1 second

        LATD2 = 0;  // Set RD2 lows
        __delay_ms(500);  // Wait for 1 second
    }
}

void UART_WriteString(const char *message)
{
    for(int i = 0; i < (int)strlen(message); i++)
    {
        while(!UART2.IsTxReady())
        {
            ;
        };
        (void) UART2.Write(message[i]);
    }
}

// Define system frequency and baud rate
#define _XTAL_FREQ 12000000  // 8 MHz internal oscillator
#define BAUD_RATE 9600      // Desired baud rate


//software base. 
//IT"S TOO SLOW.. around 8uSecond response. 
void response_to_spi(void)
{
    if(!CS_GetValue()){
        uint16_t data = 0xaaaa;
        uint16_t mask = 0x8000;
        bool val = true;
        for( int i=1; i<16; i++)
        {
            SDI_SetHigh();
            /*
            if(val){
                SDI_SetHigh();
                val = false;
            } else {
                SDI_SetLow();
                val = true;
            } */
            //push the data
            /*
            if(data & mask){
                SDI_SetHigh();
            } else  {
                SDI_SetLow();
            }
            mask = mask >> 1;
             */
            //wait for clock to go high
            while(!SCK_GetValue());
            SDI_SetLow();
            //wait for clock to go low
            while(SCK_GetValue());
        }
    }
}

void uart1_handler(void)
{
    if(!data_ptr)
    {
        high_byte_spi = EUSART1_Read();
        data_ptr = 1;
    } else {
        low_byte_spi = EUSART1_Read();
        data_ptr = 0;
    }
}


void main(void) {
    
    SYSTEM_Initialize();  // Initialize the system using MCC
    EUSART2_Enable();
    EUSART2_TransmitEnable();
    TRISAbits.TRISA0 = 1;  // Set STRAP_PIN as input
    ANSA0 = 0; 
 //   LATB3 = 1; 
    SPI1_Open(0);
        
    if (STRAP_PIN) {
//   if (false) {    
        // Master mode
        test1(1);
        UART2_SendString("Mode: master\n\r");
        if (SPI1_Open(0)) {
            LATB3 = 0;
            //TMP122_Init();
            LATB3 = 1;
            UART2_SendString("TMP122_Init done\n\r");
        } else {
            UART2_SendString("halt\n\r");
            while(1);
        }
        uint16_t temperature;  

        while (1) {
            LATB3 = 0; 
            temperature = read_temperature();
            LATB3 = 1;
            UART_SendChar((temperature >> 8) & 0xFF);  // Send high byte
            UART_SendChar(temperature & 0xFF);  // Send low byte
#ifdef DEBUG
            temperature = temperature >> 7;
            printf("Temperature: %u\n\r", temperature);  // Debugging output
#endif
            __delay_ms(50);  // Delay 1 second
        }
    } else {
        //test1(2);
        UART2_SendString("Mode: slave\n\r");
        // Slave mode
 //       SSP1CON1 = 0x05;
        //CS_TRIS = 1; //RB3 is input
        SCK_TRIS = 1; //RB5 is inputs
        uint8_t high_byte, low_byte;
        uint16_t data;
        uint8_t buffer[2]; 
        
        
        //manual override
        //SDI_TRIS = 0; //set sdi/o as output
        
//        while(1){
//            response_to_spi();
//        }
        
        bool data_ptr = 0;
        IO_RD5_TRIS = 1;
        
        bool detect_high_cs = false;
        UART2_SendString("enabling usart1\n\r");
        EUSART1_Enable();
        EUSART1_ReceiveEnable();
        EUSART1_TransmitEnable();
        UART2_SendString("registering handler\n\r");
        EUSART1_RxCompleteCallbackRegister(&uart1_handler);
        
        //UART.RxCompleteCallbackRegister(&UART_echoCharacters);
        INTERRUPT_GlobalInterruptEnable();
        INTERRUPT_PeripheralInterruptEnable();        
        
        
        UART2_SendString("entering loop\n\r");
        while (1) {
            //high_byte = UART_ReceiveChar();
            //low_byte = UART_ReceiveChar();
            //data = 0xa55a;
            //data = (high_byte << 8) | low_byte;  // Combine high and low bytes
           // if (!CS_PORT){
                //printf("Received data: %x\n\r", data);  // Debugging output
            //printf("waiting for master to read the data\n\r");
            //SPI_Write(data);  // Send data via SPI
            SSP1BUF = high_byte_spi;
            data_ptr = 1;
            while (!PIR3bits.SSP1IF)
            {
                
                //check if the ss goes up
                if(!IO_RD5_GetValue()){
                    detect_high_cs = true;
                } 
                
                if (detect_high_cs){
                    if(IO_RD5_GetValue()){
                        data_ptr = 0;
                        break;
                    }
                }
                // Wait for flag to get set */
            }
            if(data_ptr)
            {
                PIR3bits.SSP1IF = 0;            
                SSP1BUF = low_byte_spi;                
            }
            while (!PIR3bits.SSP1IF)
            {
                //check if the ss goes up
                if(IO_RD5_GetValue()){
                    data_ptr = 0;
                    break;
                }
            }
            
            //switch the data if neccessary, process here
            
            
          //  }
        }
    }
}
